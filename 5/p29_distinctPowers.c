// https://projecteuler.net/problem=29

//How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int main(){

    //gather an array of numbers first 
    int *storage = NULL; //pointer to block of memory
    
    if ((int *)malloc(sizeof(int *)*4000000) != NULL){
        storage = (int *)malloc(sizeof(int *)*4000000);
    }
    else{
        printf("Unsuccessful allocation of memory. STOP\n");
        return 0;
    }

    int start = 2;
    int finish = 100;
    int ii, jj;
    int k = 0;
    for (ii = start; ii <= finish; ii++){

        for(jj = start; jj <= finish; jj++){

            //store current powers
            storage[k] = pow(ii,jj);
            k++;

        }

    }

    //count the number of unqiue occurances (SETS ARE A FASTER WAY OF DOING THIS!!!!)
    int sz = k - 1;
    int n_unique =1;
    for (ii = 1; ii <= sz; ii++){

        for (jj = 0; jj <= sz; jj++){

            if (storage[ii] == storage[jj]){
                break;
            }

        }

        if (ii == jj){
            n_unique++; 
        }

    }

    printf("Number of unique = %d \n", n_unique);
    // issue is that the numbers are so large (100^100 = 1e200) that they wrap around
    //and don't identify properly. To over come this, instead of a brute force method, 
    // you can work in bases - however this makes things more complicated. This is actually
    // a problem with C. The largest number possible in C is 2^31 - 1. Largest in MATLAB is
    // 1.79e380 which works in our case. Hence this problem has been solved via matlab. 

    // //print just to check for now
    // int sz = k - 1;
    // for (ii = 0; ii <= sz; ii++){
    //     printf("%d, ", storage[ii]);
    // }
    // printf("\n");

    free(storage); 
    return 0;
}